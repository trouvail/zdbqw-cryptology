# `cryptography-final-job`——保密通信协议

> **学号：2013921\
姓名：周延霖\
年级：2020级\
专业：信息安全**


<!-- vscode-markdown-toc -->
* 1. [大作业内容说明](#)
	* 1.1. [实验目的](#-1)
	* 1.2. [实验要求](#-1)
	* 1.3. [假设条件](#-1)
* 2. [实验环境](#-1)
* 3. [保密通信协议](#-1)
	* 3.1. [保密通信协议设计思路](#-1)
	* 3.2. [保密通信协议设计的流程](#-1)
	* 3.3. [相关重点概念](#-1)
	* 3.4. [通讯的重要代码分析](#-1)
* 4. [`RSA`相关](#RSA)
	* 4.1. [相关概念介绍](#-1)
	* 4.2. [重要函数分析](#-1)
* 5. [`AES`相关](#AES)
	* 5.1. [流程分析](#-1)
	* 5.2. [代码实现](#-1)
	* 5.3. [`CBC`模式的补充](#CBC)
* 6. [`MD5`相关](#MD5)
	* 6.1. [概念介绍](#-1)
	* 6.2. [重要函数分析](#-1)
	* 6.3. [代码实现](#-1)
* 7. [结果展示](#-1)
	* 7.1. [开始的发送公钥和共享`AES`密钥](#AES-1)
	* 7.2. [收发消息](#-1)
* 8. [总结与展望](#-1)
	* 8.1. [总结](#-1)
	* 8.2. [展望](#-1)

<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->


##  1. <a name=''></a>大作业内容说明
---

###  1.1. <a name='-1'></a>实验目的

设计一个保密通信的协议，具体要求为：利用`RSA`公钥密码算法，为双方分配一个`AES`算法的会话密钥，然后利用`AES`加密算法和分配的会话密钥，加解密传送的信息

###  1.2. <a name='-1'></a>实验要求

1. 作业需要先设计出保密通讯协议的过程和具体步骤
2. 分别编写A，B两个用户端的程序，写清楚两个程序分别要完成的功能，并能够在两个程序间进行通讯
3. 对AES加密的保密信息，要求采用CBC模式进行加密
4. 大作业的提交方式同实验报告的提交，也就是说既要提交程序实现的说明文档，也要提交源代码和可执行程序

###  1.3. <a name='-1'></a>假设条件

假设通讯双方为`A`和`B`，并假设发方拥有自己的`RSA`公钥`PKA`和私钥`SKA`，同时收方拥有自己的`RSA`公钥`PKB`和私钥`SKB`，同时收发双方已经通过某种方式知道了双方的公钥


##  2. <a name='-1'></a>实验环境
---

- 操作系统：`macOS Montery 12.4`
- 软件系统：`Xcode`
- 编译工具：`Apple clang version 13.1.6 (clang-1316.0.21.2.5)`
- 编程语言：`C++`

**由于这次实验需要进行通讯，所以在最后实现网络通讯的时候还借助了`Windows 11`操作系统**

##  3. <a name='-1'></a>保密通信协议
---

本次实验首先对保密协议进行设计，因为保密协议其实是整体上的大局观，类似一个指导编程的思维导图，如下是保密协议的相关流程：


###  3.1. <a name='-1'></a>保密通信协议设计思路

在设计保密通信协议时，我采取了如下思路进行设计：

1. 首先选择了要求所需要的`RSA`公钥密码算法，并利用该算法为双方各分配一个公钥和一个私钥
2. 然后服务器与客户端成功进行连接之后分别将自己的公钥发送给对方
3. 在客户端使用公钥密码算法随机生成一个`AES`算法的会话密钥，并通过服务器的公钥进行加密，将加密后的密钥发送给服务器
4. 服务器收到加密后的会话密钥后，使用私钥进行解密，得到原始的`AES`会话密钥
5. 利用`AES`和`AES加密算法`，双方就可以对要传送的信息进行加密，并将加密后的信息发送给对方
6. 双方在收到加密后的信息后，利用`AES`和`AES解密算法`，对信息进行解密，就可以得到原始信息，实现双方的通讯

**在这里的`AES加解密`都是使用的`CBC模式`，通讯采用的是`TCP`模式下的通讯**

在以上步骤在设计保密通信协议完后，我发现对于本学期后半的课程所学的知识用到的并不多，所以添加了一些额外的步骤来保证信息的安全性，比如：

1. 双方可以在发送加密后的信息之前，通过数字签名的方式对信息进行签名，以验证信息的完整性和可靠性
2. 双方可以在接收到加密后的信息之后，使用消息认证码 (MAC）的方式对信息进行认证，以防止信息被篡改
3. 双方可以利用时间戳的方式，对信息进行时间限制，以防止信息被重放

###  3.2. <a name='-1'></a>保密通信协议设计的流程

***(1)开始的利用`AES`和`RSA`实现的通讯***

> 通讯的总体流程图如下：

![](https://i.imgtg.com/2022/12/28/EJPys.jpg)

1. 首先是服务端先建立socket端口，并绑定端口的IP地址以及端口号
2. 然后服务器开始监听，此时客户端也需要绑定socket并发出连接请求
3. 当服务器收到了连接请求并成功与客户端建立连接之后，先有服务器将自己的公钥发给客户端，然后客户端再将自己的公钥发给服务器，实现了双发可以知道对方的公钥
4. 接下来有客户端随机生成一个AES密钥，并将此密钥用服务器的公钥进行加密发送给服务器
5. 服务器端将其用自己的私钥进行解密，然后就可以实现AES的密钥共享了
6. 接下来双方进行信息传输的时候，先使用AES的CBC模式进行对明文信息的加密，然后每一次再用对方的公钥再次加密并对其进行传输
7. 接收到信息后先用自己的私钥对其进行解密，然后用共享的AES密钥对其进行解密，然后将解密的信息在程序中输出，即实现了双方的通讯
8. 最后当任意一方输入`exit`后将结束本次对话，双方都需要关闭socket然后退出程序





***(2)后来补充的认证和签名***


因为以上实现的程序总感觉还欠缺点什么，所以又对其加密传输过程进行了消息验证码（MAC）和数字签名的补充，更能符合这学期密码学课程设置的要求

> 补充的加密传输流程图如下：

![](https://i.imgtg.com/2022/12/28/EJRsK.jpg)

1. 首先将明文信息用MD5哈希加密，并用自己的私钥再次进行加密，以达到签名的目的
2. 然后将明文消息与刚刚经过两次加密的密文消息整合
3. 接下来将整合的消息进行加密，此处是用AES和对方的公钥进行加密，达到保密的目的
4. 然后收方在收到消息之后对其进行解密，用自己的私钥和AES共享密钥进行解密
5. 将明文信息用MD5进行哈希加密，并和用对方的公钥解密的密文信息进行比较，达到认证的目的

**这是一种最常用的方式，实现了`认证`和`签名`和`保密`的功能**





###  3.3. <a name='-1'></a>相关重点概念


***(1)消息认证码（`MAC`）***

消息认证码（Message Authentication Code）是一种确认完整性并进行认证的计算，取三个单词的首字母，简称MAC：

- 消息认证码的输入包括任意长度的消息和一个发送者与接收者之间的共享的密钥，它可以输出固定长度的数据，这个数据成为MAC值
- 根据任意长度的雄性输出固定长度的数据，这一点和散列函数很类似。但是单向散列函数中计算散列值时不需要密钥，相对地，消息认证码中则需要使用发送者与接收者之间的共享密钥
- 要计算MAC必须持有共享密钥，没有共享密钥的人就无法计算MAC值，消息认证正是利用这一性质来完成认证的。此外，和单向散列函数的散列值一样，哪怕消息中发生1比特的变化，MAC值一会产生变化，消息认证码正是利用这一性质来确认完整性的。


**消息认证码是一种与密钥相关联的单向散列函数**

> 应用实例

**SWIFT**


SWIFT的全称是Society for Worldwide Interbank Financial Telecommunication（环境银行金融电信协会），是于1973年成立的一个组织，其目的是为国际银行之间的交易保驾护航。该组织成立时有15个成员国，2008年时，已经发展到了208个成员国。
 

银行与银行之间是通过SWIFT来传递交易信息的。而为了确认消息的完整性以及对消息进行验证，SWIFT中使用了消息认证码。
 

在使用公钥密码进行密钥交换之前，消息认证码所使用的共享密钥都是由人来进行配送的。

**IPsec**
 

IPsec 是对互联网基本通信协议——IP协议（Internet Protocol）增加安全性的一种方式。IPsec中，对通信内容的认证和完整性校验都是采用的消息认证吗来完成的。

**SSL/TLS**
 

SSL/TLS是我们在网上购物等场景中所使用的通信协议。 SSL/TLS中对通信内容的认证和完整性校验也使用了消息认证吗。

> 实现方式

**使用单向散列函数实现**
 

使用SHA-2之类的单向散列函数可以实现消息认证码，其中一种实现方法称为HMAC。

**使用分组密码实现（也是本次实验采取的方式）**
 

使用AES之类的分组密码可以实现消息认证码。
 

将分组密码的密钥作为消息认证码的共享密钥来使用，并用CBC模式将消息全部加密。此时，初始化向量是固定的。由于消息认证码不需要解密，因此将除最后一个分组以外的密文部分全部丢弃，而将最后一个分组用作MAC值。由于CBC模式的最后一个分组会受到整个消息以及密钥的双重影响，因此可以将它用作消息认证码。例如AES-CMAC（RFC4493）就是一种基于AES来实现的消息认证码。

**其他实现方法**
 

使用流密码和公钥密码等也可以实现消息认证码。


***(2)数字签名***


> 基本原理

先说数字签名的基本原理。数字签名过程跟加密通信有着一定的对称性，这种对称有着一种逻辑上的美。


加密通信是用公钥进行加密，而用私钥进行解密。而数字签名刚好相反，是采用私钥加密，公钥解密。对于加密通信，公钥加密过程就是通过加密算法把信息加密成密文，私钥解密过程就是通过解密算法解密密文。而对于数字签名，私钥加密过程是通过签名算法来生成数字签名的过程，而公钥解密过程是通过验证算法来确定数字签名是不是有私钥持有者签署的。可以看到，加密算法，解密算法，签名算法，验证算法，对称性是很明显的。


数字签名的主要的作用是认证签署人身份，说得具体点，就是让所有人能够确认这个数字签名是不是由私钥的持有人创建的。数字签名是由签名算法去生成的，签名算法的输入有两个，一个是私钥，另一个是被签署的信息，输出的一个字符串就是数字签名了。签名到底是不是由私钥持有人签署的，要通过验证算法判断。验证算法有三个输入，一个是信息本身，另外一个是数字签名，第三个是公钥，输出的结果就是验证成功或者验证失败。数字签名过程中，私钥是`签名 key`，公钥是`验证 key`。


> 实际作用

然后是数字签名的作用。数字签名有三大作用，第一个是认证，第二个是防止抵赖，第三个是保证文件完整性，也就是没有被篡改过。


先看第一个认证，意思就是确认签署人身份，这个跟纸笔签名的作用是一致的。再看第二个防止抵赖，同样是纸笔签名也拥有的特性，一份合同签署了，就要承担责任，白纸黑字，不能耍赖。第三个作用是保证文件没有被篡改过，这个作用纸笔签名很难保证，比如签名只签署了最后一页，那么如果有人想悄悄换掉了前几页的内容，签名本身是阻止不了的。但是数字签名就可以，因为数字签名是由两个输入运算得出的，一个是私钥，另一个就是文件，所以如果在验证过程中，发现文件有改动，验证会失败。这个很类似于现实世界签合同的时候，有时候需要故意用签名或者图章覆盖有文字的区域，或者在写信的时候，给信封加上蜡封，这些措施也都是为了防篡改。


这就是数字签名的三大作用，主要用在各种防伪造场合，在世界上很多国家，数字签名都是有法律效力的。另外要注意，数字签名属于电子签名的一种，但并不是所有的电子签名都是数字签名，这两个概念要区分一下。

> 总结

数字签名是公钥加密技术的两大应用之一。主要采用了私钥加密，公钥解密的方式，文件签署者用私钥签署文件，就表示他认可了这个文件的内容。要验证数字签名，只需要签名人公布自己的公钥即可，其他人通过验证数字签名即可验证文件是私钥签署的。签署人不需要暴露自己的私钥，就可以间接证明自己拥有私钥。除了认证签署人身份，数字签名还有两个作用，分别是防止抵赖和保证文件完整性。




###  3.4. <a name='-1'></a>通讯的重要代码分析

这一次分为了好几个部分进行实现所以加密的部分代码以及消息认证等代码实现都会分节讲述，这一节讲述的主要代码是通讯的部分，由于通讯实现包装化，所以在主函数中服务器端和客户端分别只有一个`runServer()`和`runClient()`函数，这也是本次重点要讲的两部分代码：

***(1)`runClient()`***


- 其实客户端大致的流程已经在上述中讲到了，先加载套接字库、创建一个套接字供使用、然后向服务器发出连接请求
- 然后客户端先接收对面发来的公钥，接着把自己的公钥发过去，然后发送一个共享的AES密钥
- 最后的收发信息也是用补充完认证和签名机制后的流程来实现

代码如下：

```c++
int runClient()
{
	// 1.加载套接字库
	WORD wVersionRequested;
	WSADATA wsaData;
	wVersionRequested = MAKEWORD(2, 2);
	int err = WSAStartup(wVersionRequested, &wsaData);
	if (err) 
		printf("C: socket加载失败\n"); 
	else 
		printf("C: socket加载成功\n"); 
	// 2.创建一个套接字供使用
	SOCKET ServerSocket = socket(AF_INET, SOCK_STREAM, 0);
	// 3.向服务器发出连接请求
	SOCKADDR_IN socksin; // 记录服务器端地址
	socksin.sin_family = AF_INET;
	socksin.sin_port = htons(6020);
	socksin.sin_addr.S_un.S_addr = inet_addr("127.0.0.1");
	int rf = connect(ServerSocket, (SOCKADDR*)&socksin, sizeof(socksin));
	if (rf == SOCKET_ERROR)
		printf("C: 与服务器连接失败\n");
	else
	{
		printf("C: 成功与服务器进行连接\n");




		// 接收公钥对 客户端应该也需要自己的公私钥
		// 采用服务端先发送 客户端后发送的策略 并准备一个flag 服务端为0 客户端为1
		// 一 客户端接收
		char recv_from_server_public_key[100] = { 0 };
		recv(ServerSocket, recv_from_server_public_key, 100, 0);
		printf("C: 从服务器接收服务器的公钥对:%s\n", recv_from_server_public_key);
		char recv_N[100], recv_E[100];
		int count_for_N = 0, count_for_E = 0;
		bool divide_for_key = false;
		for (int i = 0; i < strlen(recv_from_server_public_key); i++)
		{
			if (recv_from_server_public_key[i] == ',') { divide_for_key = true; continue; }
			if (!divide_for_key) 
				recv_N[count_for_N++] = recv_from_server_public_key[i];
			else 
				recv_E[count_for_E++] = recv_from_server_public_key[i];
		}

		PublicKey server_public_key;
		server_public_key.nE = atoi(recv_E);
		server_public_key.nN = atoll(recv_N);


		// 二 客户端发送
		RsaParam client_param = RsaGetParam();
		m_cParament.d = client_param.d;
		m_cParament.e = client_param.e;
		m_cParament.n = client_param.n;
		PublicKey client_public_key = GetPublicKey();
		char send_to_server_public_key[100], send_N[100], send_E[100];
		sprintf(send_N, "%lu", client_public_key.nN);
		itoa(client_public_key.nE, send_E, 10);
		strcpy(send_to_server_public_key, send_N);
		int len_of_N = strlen(send_N), len_of_E = strlen(send_E);
		send_to_server_public_key[len_of_N] = ',';
		strncpy(send_to_server_public_key + len_of_N + 1, send_E, len_of_E);
		send_to_server_public_key[len_of_N + len_of_E + 1] = '\0';
		printf("C: 向服务器发送客户端的公钥对:%s\n", send_to_server_public_key);
		send(ServerSocket, send_to_server_public_key, strlen(send_to_server_public_key), 0);



		// 准备发送AES密钥
		char en_aes_key[300] = { '\0' };
		char aes_key[16] = { 0 };
		GenerateAesKey(aes_key);
		printf("C: 随机生成一个AES密钥:");
		for (int i = 0; i < 16; i++) {
			printf("%c", aes_key[i]);
		}
		printf("\n");
		int len_of_en_aes_key = 0;
		for (int i = 0; i < 8; i++)
		{
			int p1 = i * 2, p2 = i * 2 + 1;
			int num1 = int(aes_key[p1]);
			int num2 = int(aes_key[p2]);
			UINT64 sixteen_bits = (num1 << 8) + num2;
			UINT64 en_sixteen_bits = Encry(sixteen_bits, server_public_key);
			char en_sixteen_bits_to_char[20];
			sprintf(en_sixteen_bits_to_char, "%lu", en_sixteen_bits);
			strncpy(en_aes_key + len_of_en_aes_key, en_sixteen_bits_to_char, strlen(en_sixteen_bits_to_char));
			len_of_en_aes_key += strlen(en_sixteen_bits_to_char);
			char comma = ',';
			en_aes_key[len_of_en_aes_key] = comma;
			len_of_en_aes_key += 1;
		}
		en_aes_key[len_of_en_aes_key] = '\0';
		// 发送加密的AES密钥给服务器
		printf("C: 向服务器发送加密的AES密钥:%s\n", en_aes_key);
		send(ServerSocket, en_aes_key, len_of_en_aes_key, 0);




		// 开始准备收发信息
		char plaintext[500], ciphtext[500] = { 0 };
		while (true)
		{  
			string str_aes_key = charkey_to_strkey(aes_key);

			// 一 客户端发送加密信息
			// 补充：先用哈希（MD5）进行加密 这个值再用私钥加密 后与整体进行一起加密
			printf("C: 请输入明文:");
			setbuf(stdin, NULL);
			scanf("%[^\n]s", plaintext); // 使得空行代表读取完毕而不是空格
			bool exit = false;
			if (strcmp(plaintext, "exit") == 0) { exit = true; }
			string mid_plain_text = plaintext;
			// hash也是32个16进制数的字符串
			string hash = MD5(mid_plain_text).getstring();
			PublicKey client_private_key;
			client_private_key.nE = m_cParament.d;
			client_private_key.nN = m_cParament.n;
			// 用自己的私钥去加密
			char en_hash[100] = { '\0' };
			int len_of_en_text = 0;
			for (int i = 0; i < hash.size() / 4; i++)
			{
				int p1 = i * 4, p2 = i * 4 + 1;
				int p3 = i * 4 + 2, p4 = i * 4 + 3;
				int num1 = int(hash[p1]);
				int num2 = int(hash[p2]);
				int num3 = int(hash[p1]);
				int num4 = int(hash[p2]);
				UINT64 sixteen_bits = (num1 << 12) + (num2 << 8) + (num3 << 4) + num4;
				UINT64 en_sixteen_bits = Encry(sixteen_bits, client_private_key);
				char en_sixteen_bits_to_char[20];
				sprintf(en_sixteen_bits_to_char, "%lu", en_sixteen_bits);
				strncpy(en_hash + len_of_en_text, en_sixteen_bits_to_char, strlen(en_sixteen_bits_to_char));
				len_of_en_text += strlen(en_sixteen_bits_to_char);
			}
			en_hash[len_of_en_text] = '\0';
			string wxn_en_hash = en_hash;
			// 1.输入信息 并将其用AES加密为128位的数据 需要实现CBC分组加密 即需要加上xor 并将分组加密完的数据合成一个字符串
			// 为了方便区分最后的hash
			mid_plain_text += ".";
			mid_plain_text += wxn_en_hash;
			string mid_en_text = en_cbc_aes(mid_plain_text, str_aes_key); // 返回的是一个CBC分组加密完合成的字符串
			// 2.用对方的公钥(server_public_key)进行加密 由于合成的字符串每一个字符是4位 所以需要4个为一组
			char en_text[500] = { '\0' };
			int len_of_en_text = 0;
			for (int i = 0; i < mid_en_text.size() / 4; i++)
			{
				int p1 = i * 4, p2 = i * 4 + 1;
				int p3 = i * 4 + 2, p4 = i * 4 + 3;
				int num1 = int(mid_en_text[p1]);
				int num2 = int(mid_en_text[p2]);
				int num3 = int(mid_en_text[p1]);
				int num4 = int(mid_en_text[p2]);
				UINT64 sixteen_bits = (num1 << 12) + (num2 << 8) + (num3 << 4) + num4;
				UINT64 en_sixteen_bits = Encry(sixteen_bits, server_public_key);
				char en_sixteen_bits_to_char[20];
				sprintf(en_sixteen_bits_to_char, "%lu", en_sixteen_bits);
				strncpy(en_text + len_of_en_text, en_sixteen_bits_to_char, strlen(en_sixteen_bits_to_char));
				len_of_en_text += strlen(en_sixteen_bits_to_char);
				char comma = ',';
				en_text[len_of_en_text] = comma;
				len_of_en_text += 1;
			}
			en_text[len_of_en_text] = '\0';
			// 3.将加密完的字符串发送
			send(ServerSocket, en_text, strlen(en_text), 0);
			if (exit)
			{
				break;
			}
			


			// 二 客户端接收加密信息
			// 1.接收对方发过来的字符串
			recv(ServerSocket, ciphtext, 500, 0);
			// 2.用自己的私钥(client_private_key)解密发过来的字符串
			int len_of_ciphtext = 0;
			for (int i = 0; i < strlen(ciphtext) / 4; i++)
			{
				if (en_aes_key[len_of_ciphtext++] == '.')
				{
					// 判断到加密后的hash值了
					break;
				}
				char en_sixteen_bits_to_char[20] = { '\0' };
				int p = 0;
				while (en_aes_key[len_of_ciphtext++] != ',')
					en_sixteen_bits_to_char[p++] = en_aes_key[len_of_ciphtext - 1];
				UINT64 en_sixteen_bits = atoll(en_sixteen_bits_to_char);
				UINT64 sixteen_bits = Decry(en_sixteen_bits);
				ciphtext[i * 4] = (sixteen_bits >> 12) % 16;
				ciphtext[i * 4 + 1] = (sixteen_bits >> 8) % 16;
				ciphtext[i * 4 + 2] = (sixteen_bits >> 4) % 16;
				ciphtext[i * 4 + 3] = sixteen_bits % 16;
			}
			string mid_ciphtext = ciphtext;
			// 补充：对hash的解密 需要用服务器的公钥解密
			char recv_en_hash[100];
			// 先保存之前的秘钥 防止丢失
			UINT64 mid_n = m_cParament.n;
			UINT64 mid_d = m_cParament.d;
			UINT64 mid_e = m_cParament.e;
			// 赋值为服务器的公钥（server_public_key）
			m_cParament.n = server_public_key.nN;
			m_cParament.d = server_public_key.nE;
			for (int i = 0; i < strlen(ciphtext) / 4; i++)
			{
				if (en_aes_key[len_of_ciphtext++] == '.')
				{
					// 判断到加密后的hash值了
					break;
				}
				char en_sixteen_bits_to_char[20] = { '\0' };
				int p = 0;
				while (en_aes_key[len_of_ciphtext++] != ',')
					en_sixteen_bits_to_char[p++] = en_aes_key[len_of_ciphtext - 1];
				UINT64 en_sixteen_bits = atoll(en_sixteen_bits_to_char);
				UINT64 sixteen_bits = Decry(en_sixteen_bits);
				recv_en_hash[i * 4] = (sixteen_bits >> 12) % 16;
				recv_en_hash[i * 4 + 1] = (sixteen_bits >> 8) % 16;
				recv_en_hash[i * 4 + 2] = (sixteen_bits >> 4) % 16;
				recv_en_hash[i * 4 + 3] = sixteen_bits % 16;
			}
			// 恢复之前的缓冲区
			m_cParament.n = mid_n;
			m_cParament.d = mid_d;
			m_cParament.e = mid_e;
			string recv_hash = recv_en_hash;
			// 3.将其用AES解密(在解密函数中将其分为128位一组的数据)各个组的128位的数据 需要实现CBC分组解密 即需要加上xor
			string de_mid_ciphtext = de_cbc_aes(mid_ciphtext, str_aes_key);
			// 4.输出解密后的明文(如果hash值验证相等的话)
			if (MD5(de_mid_ciphtext).getstring() == recv_hash)
			{
				char* time;
				strcpy(time, getTime());
				printf("C: [%s]经过解密后的明文:", time);
				cout << de_mid_ciphtext;
				if (de_mid_ciphtext == "exit")
				{
					break;
				}
			}
			else
			{
				cout << "本次接收有误，需要重新接收" << endl;
				continue;
			}
		}
		//如果用户选择退出，则向服务器发送退出请求
		printf("\nC: 退出...");
	}
	closesocket(ServerSocket);
	WSACleanup();
	return 0;
}
```

***(2)`runServer()`***

- 其实服务器端大致的流程也在上述中讲到了，先加载套接字库、创建一个套接字供使用、将套接字绑定到本地地址和端口上、然后将套接字设置为监听模式，以接收客户端请求并等待并接收客户端请求，返回新的连接套接字
- 然后服务器先发送自己的公钥，接着等待接收对方的公钥，然后等待对方的发来的共享AES密钥
- 最后的收发信息也是用补充完认证和签名机制后的流程来实现



代码如下：

```c++
int runServer()
{
	//1.加载套接字库
	WORD wVersionRequested = MAKEWORD(2, 2);
	WSADATA wsaData;
	int err = WSAStartup(wVersionRequested, &wsaData);
	if (err) 
		printf("S: socket加载失败\n"); 
	else 
		printf("S: socket加载成功\n"); 
	//2.创建一个套接字供使用
	SOCKET ServerSocket = socket(AF_INET, SOCK_STREAM, 0);
	//3.将套接字绑定到本地地址和端口上
	SOCKADDR_IN addr;
	addr.sin_family = AF_INET;
	addr.sin_port = htons(6020);
	addr.sin_addr.S_un.S_addr = htonl(INADDR_ANY);
	bind(ServerSocket, (SOCKADDR*)&addr, sizeof(SOCKADDR));
	//4.将套接字设置为监听模式，以接收客户端请求
	err = listen(ServerSocket, 5);
	if (err)
		printf("S: 绑定端口失败 请重新启动程序\n"); 
	else 
		printf("S: 成功绑定端口 等待客户端连接\n"); 
	//5.等待并接收客户端请求，返回新的连接套接字
	SOCKADDR_IN addr_out;
	int len = sizeof(SOCKADDR);
	SOCKET ClientSocket = accept(ServerSocket, (SOCKADDR*)&addr_out, &len);



	// 6.计算密钥 主要是RSA的公钥和私钥 并准备发给客户端 需要补充的是从客户端接收
	// 采用服务端先发送 客户端后发送的策略 并准备一个flag 服务端为0 客户端为1
	// 一 服务器发送
	RsaParam server_param = RsaGetParam();
	m_cParament.d = server_param.d;
	m_cParament.e = server_param.e;
	m_cParament.n = server_param.n;
	PublicKey server_public_key = GetPublicKey();
	char send_to_client_public_key[100], send_N[100], send_E[100];
	sprintf(send_N, "%lu", server_public_key.nN);
	itoa(server_public_key.nE, send_E, 10);
	strcpy(send_to_client_public_key, send_N);
	int len_of_N = strlen(send_N), len_of_E = strlen(send_E);
	send_to_client_public_key[len_of_N] = ',';
	strncpy(send_to_client_public_key + len_of_N + 1, send_E, len_of_E);
	send_to_client_public_key[len_of_N + len_of_E + 1] = '\0';
	printf("S: 向客户端发送服务器的公钥对:%s\n", send_to_client_public_key);
	send(ClientSocket, send_to_client_public_key, strlen(send_to_client_public_key), 0);

	// 二 服务器接收
	char recv_from_client_public_key[100] = { 0 };
	recv(ClientSocket, recv_from_client_public_key, 100, 0);
	printf("S: 从客户端接收客户端的公钥对:%s\n", recv_from_client_public_key);
	char recv_N[100], recv_E[100];
	int count_for_N = 0, count_for_E = 0;
	bool divide_for_key = false;
	for (int i = 0; i < strlen(recv_from_client_public_key); i++)
	{
		if (recv_from_client_public_key[i] == ',') { divide_for_key = true; continue; }
		if (!divide_for_key)
			recv_N[count_for_N++] = recv_from_client_public_key[i];
		else
			recv_E[count_for_E++] = recv_from_client_public_key[i];
	}

	PublicKey client_public_key;
	client_public_key.nE = atoi(recv_E);
	client_public_key.nN = atoll(recv_N);
	//char encryKey[300];


	// 接收加密的AES密钥
	char aes_key[20] = { '\0' };
	char en_aes_key[300] = { '\0' };
	recv(ClientSocket, en_aes_key, 300, 0); // 接收密钥
	printf("S: 从客户端接收到加密的AES密钥:%s\n", en_aes_key);
	int len_of_en_aes_key = 0;
	for (int i = 0; i < 8; i++)
	{
		char en_sixteen_bits_to_char[20] = { '\0' };
		int p = 0;
		while (en_aes_key[len_of_en_aes_key++] != ',')
			en_sixteen_bits_to_char[p++] = en_aes_key[len_of_en_aes_key - 1];
		UINT64 en_sixteen_bits = atoll(en_sixteen_bits_to_char);
		UINT64 sixteen_bits = Decry(en_sixteen_bits);
		aes_key[i * 2] = sixteen_bits >> 8;
		aes_key[i * 2 + 1] = sixteen_bits % 256;
	}
	printf("S: 解密的AES密钥为:%s\n", aes_key);



	// 准备收发消息
	char plaintext[500], ciphtext[500] = { 0 };
	while (true)
	{
		string str_aes_key = charkey_to_strkey(aes_key);

		// 一 服务器接收加密信息
		// 1.接收对方发过来的字符串
		recv(ClientSocket, ciphtext, 500, 0);
		// 2.用自己的私钥(server_private_key)解密发过来的字符串
		int len_of_ciphtext = 0;
		for (int i = 0; i < strlen(ciphtext) / 4; i++)
		{
			if (en_aes_key[len_of_ciphtext++] == '.')
			{
				// 判断到加密后的hash值了
				break;
			}
			char en_sixteen_bits_to_char[20] = { '\0' };
			int p = 0;
			while (en_aes_key[len_of_ciphtext++] != ',')
				en_sixteen_bits_to_char[p++] = en_aes_key[len_of_ciphtext - 1];
			UINT64 en_sixteen_bits = atoll(en_sixteen_bits_to_char);
			UINT64 sixteen_bits = Decry(en_sixteen_bits);
			ciphtext[i * 4] = (sixteen_bits >> 12) % 16;
			ciphtext[i * 4 + 1] = (sixteen_bits >> 8) % 16;
			ciphtext[i * 4 + 2] = (sixteen_bits >> 4) % 16;
			ciphtext[i * 4 + 3] = sixteen_bits % 16;
		}
		string mid_ciphtext = ciphtext;
		// 补充：对hash的解密 需要用服务器的公钥解密
		char recv_en_hash[100];
		// 先保存之前的秘钥 防止丢失
		UINT64 mid_n = m_cParament.n;
		UINT64 mid_d = m_cParament.d;
		UINT64 mid_e = m_cParament.e;
		// 赋值为客户端的公钥（client_public_key）
		m_cParament.n = client_public_key.nN;
		m_cParament.d = client_public_key.nE;
		for (int i = 0; i < strlen(ciphtext) / 4; i++)
		{
			if (en_aes_key[len_of_ciphtext++] == '.')
			{
				// 判断到加密后的hash值了
				break;
			}
			char en_sixteen_bits_to_char[20] = { '\0' };
			int p = 0;
			while (en_aes_key[len_of_ciphtext++] != ',')
				en_sixteen_bits_to_char[p++] = en_aes_key[len_of_ciphtext - 1];
			UINT64 en_sixteen_bits = atoll(en_sixteen_bits_to_char);
			UINT64 sixteen_bits = Decry(en_sixteen_bits);
			recv_en_hash[i * 4] = (sixteen_bits >> 12) % 16;
			recv_en_hash[i * 4 + 1] = (sixteen_bits >> 8) % 16;
			recv_en_hash[i * 4 + 2] = (sixteen_bits >> 4) % 16;
			recv_en_hash[i * 4 + 3] = sixteen_bits % 16;
		}
		// 恢复之前的缓冲区
		m_cParament.n = mid_n;
		m_cParament.d = mid_d;
		m_cParament.e = mid_e;
		string recv_hash = recv_en_hash;
		// 3.将其用AES解密(在解密函数中将其分为128位一组的数据)各个组的128位的数据 需要实现CBC分组解密 即需要加上xor
		string de_mid_ciphtext = de_cbc_aes(mid_ciphtext, str_aes_key);
		// 4.输出解密后的明文(如果hash值验证相等的话)
		if (MD5(de_mid_ciphtext).getstring() == recv_hash)
		{
			char* time;
			strcpy(time, getTime());
			printf("S: [%s]经过解密后的明文:", time);
			cout << de_mid_ciphtext;
			if (de_mid_ciphtext == "exit")
			{
				break;
			}
		}
		else
		{
			cout << "本次接收有误，需要重新接收" << endl;
			continue;
		}



		// 二 服务器发送加密信息
		// 补充：先用哈希（MD5）进行加密 这个值再用私钥加密 后与整体进行一起加密
		printf("S: 请输入明文:");
		setbuf(stdin, NULL);
		scanf("%[^\n]s", plaintext); // 使得空行代表读取完毕而不是空格
		bool exit = false;
		if (strcmp(plaintext, "exit") == 0) { exit = true; }
		string mid_plain_text = plaintext;
		// hash也是32个16进制数的字符串
		string hash = MD5(mid_plain_text).getstring();
		PublicKey server_private_key;
		server_private_key.nE = m_cParament.d;
		server_private_key.nN = m_cParament.n;
		// 用自己的私钥去加密
		char en_hash[100] = { '\0' };
		int len_of_en_text = 0;
		for (int i = 0; i < hash.size() / 4; i++)
		{
			int p1 = i * 4, p2 = i * 4 + 1;
			int p3 = i * 4 + 2, p4 = i * 4 + 3;
			int num1 = int(hash[p1]);
			int num2 = int(hash[p2]);
			int num3 = int(hash[p1]);
			int num4 = int(hash[p2]);
			UINT64 sixteen_bits = (num1 << 12) + (num2 << 8) + (num3 << 4) + num4;
			UINT64 en_sixteen_bits = Encry(sixteen_bits, server_private_key);
			char en_sixteen_bits_to_char[20];
			sprintf(en_sixteen_bits_to_char, "%lu", en_sixteen_bits);
			strncpy(en_hash + len_of_en_text, en_sixteen_bits_to_char, strlen(en_sixteen_bits_to_char));
			len_of_en_text += strlen(en_sixteen_bits_to_char);
		}
		en_hash[len_of_en_text] = '\0';
		string wxn_en_hash = en_hash;
		// 1.输入信息 并将其用AES加密为128位的数据 需要实现CBC分组加密 即需要加上xor 并将分组加密完的数据合成一个字符串
		// 为了方便区分最后的hash
		mid_plain_text += ".";
		mid_plain_text += wxn_en_hash;
		string mid_en_text = en_cbc_aes(mid_plain_text, str_aes_key); // 返回的是一个CBC分组加密完合成的字符串
		// 2.用对方的公钥(client_public_key)进行加密 由于合成的字符串每一个字符是4位 所以需要4个为一组
		char en_text[500] = { '\0' };
		int len_of_en_text = 0;
		for (int i = 0; i < mid_en_text.size() / 4; i++)
		{
			int p1 = i * 4, p2 = i * 4 + 1;
			int p3 = i * 4 + 2, p4 = i * 4 + 3;
			int num1 = int(mid_en_text[p1]);
			int num2 = int(mid_en_text[p2]);
			int num3 = int(mid_en_text[p1]);
			int num4 = int(mid_en_text[p2]);
			UINT64 sixteen_bits = (num1 << 12) + (num2 << 8) + (num3 << 4) + num4;
			UINT64 en_sixteen_bits = Encry(sixteen_bits, client_public_key);
			char en_sixteen_bits_to_char[20];
			sprintf(en_sixteen_bits_to_char, "%lu", en_sixteen_bits);
			strncpy(en_text + len_of_en_text, en_sixteen_bits_to_char, strlen(en_sixteen_bits_to_char));
			len_of_en_text += strlen(en_sixteen_bits_to_char);
			char comma = ',';
			en_text[len_of_en_text] = comma;
			len_of_en_text += 1;
		}
		en_text[len_of_en_text] = '\0';
		// 3.将加密完的字符串发送
		send(ClientSocket, en_text, strlen(en_text), 0);
		if (exit)
		{
			break;
		}
	}
	printf("\nS: 退出...");

	//关闭套接字
	closesocket(ServerSocket);
	WSACleanup();
	return 0;
}
```


##  4. <a name='RSA'></a>`RSA`相关
---


###  4.1. <a name='-1'></a>相关概念介绍

> 公钥密码体系的基本概念

传统对称密码体制要求通信双方使用相同的密钥，因此应用系统的安全性完全依赖于密钥的保密。针对对称密码体系的缺陷，Differ 和 Hellman 提出了新的密码体系—公钥密码体系，也称为非对称密码体系。在公钥加密系统中，加密和解密使用两把不同的密钥。加密的密钥（公钥）可以向公众公开，但是解密的密钥(私钥)必须是保密的，只有解密方知道。公钥密码体系要求算法要能够保证：任何企图获取私钥的人都无法从公钥中推算出来。


公钥密码体制中最著名算法是 RSA，以及背包密码、McEliece 密码、Diffe_Hellman、Rabin、零知识证明、椭圆曲线、EIGamal 算法等。


> 公钥密码体系的特点


**公钥密码体制如下部分组成：**

1. 明文：作为算法的输入的消息或者数据
2. 加密算法：加密算法对明文进行各种代换和变换
3. 密文：作为算法的输出，看起来完全随机而杂乱的数据，依赖明文和密钥。对于给定的消息，不同的密钥将产生不同的密文，密文是随机的数据流，并且其意义是无法理解的
4. 公钥和私钥：公钥和私钥成对出现，一个用来加密，另一个用来解密
5. 解密算法：该算法用来接收密文，解密还原出明文。



> `RSA`加密算法的基本工作原理

RSA 加密算法是一种典型的公钥加密算法。RSA 算法的可靠性建立在分解大整数的困难性上。假如找到一种快速分解大整数算法的话，那么用 RSA 算法的安全性会极度下降。但是存在此类算法的可能性很小。目前只有使用短密钥进行加密的 RSA 加密结果才可能被穷举解破。只要其钥匙的长度足够长，用 RSA 加密的信息的安全性就可以保证。




###  4.2. <a name='-1'></a>重要函数分析

大素数生成（512位）

**原理：**

1. **线性同余算法生成随机数**

   - 该算法产生的是伪随机数，只具有统计意义上的随机性，**易被攻破**，不宜在现实情况中使用
   - 参数：
     - 模数：$m(m>0)$，为使随机数的周期尽可能大，m应尽量大，本次实验取$m=2^{31}-1$
     - 乘数：$a(0\leq a<m)$，是m的原根，$eg. a=7^5=16807$
     - 增量：$c$（本次实验中取0）
     - 初值种子：$X_0$，随机选取一32位整数，
   - 随机数序列：$X_{n+1}=(aX_n+c)\bmod n$

2. **Rabin-Miller素数概率检测算法**

   - 定理1：如果$p$为大于2的素数，则方程$x^2\equiv 1(\bmod p)$的解只有$x\equiv 1$ 和 $x \equiv -1$

   - 定理2：若$n$为素数，则$a^{n-1}\equiv1 \bmod n$

   - 每轮检测的伪代码：

     ```C
     witness(a,n){
         d=1;//d初值为1
         for i=k downto 0 do{
             x=d;
             d=(d^2) % n;
             if(d==1&&x!=1&&x!=n-1)//若为素数，x不可能不是1或n-1
                 return FALSE;
             if (n-1的2^i位为1)//
                 d=(d*a) % n;
         }
         if(d!=1)return FALSE;//定理2
         return TRUE;
     }
     ```

   - 该算法为概率性检测，若进行s轮检测，则是素数的概率至少为$1-2^{-s}$
   
3. **Eratosthenes筛素数**

**程序框图：**

![image-20210508195843864](https://i.imgtg.com/2022/12/28/EJcWt.png)


**构建n的长度为1024比特的RSA算法，并利用该算法实现对明文的加密和解密。**

**程序框图**

![image-20210508200351702](https://i.imgtg.com/2022/12/28/EJdgx.png)

1. 生成密钥对

   ```C++
   RSA_::RSA_(big p, big q,big e)
   {
   	big v1;
   	v1.set(1);
   
   	this->p = p;
   	this->q = q;
   	this->e = e;
   
   	n = mul(p, q);//n=pq
   	big p1, q1;
   	p1 = sub(p, v1);//p-1
   	q1 = sub(q, v1);//q-1
   
   	phi = mul(p1, q1);//phi=(p-1)(q-1)
   	d = getinv(phi, e);//逆元
   }
   ```

2. 加密

   ```C++
   RSAen_::RSAen_(RSA_ a, big m)
   {
   	this->n = a.n;
   	this->e = a.e;
   	this->m = m;
   
   	c = pow(m, e, n);//m^e mod n
   }
   ```

3. 解密

   ```C++
   RSAde_::RSAde_(RSA_ a, big c)
   {
   	this->n = a.n;
   	this->d = a.d;
   	this->c = c;
   
   	m = pow(c, d, n);//c^d mod n
   }
   ```



##  5. <a name='AES'></a>`AES`相关
---

###  5.1. <a name='-1'></a>流程分析


***密钥扩展***

AES 算法通过密钥扩展程序（Key Expansion）将用户输入的密钥 K 扩展生成 `Nb(Nr+1)`个字，存放在一个线性数组`w[Nb*(Nr+1)]`中。具体如下：

1. 位置变换函数`loop_wordbyte()`，接受一个字 [a0, a1, a2, a3] 作为输入，循环左移一个字节后输出 [a1, a2, a3, a0]。
2. S盒变换函数`wordbyte_sub()`，接受一个字 [a0, a1, a2, a3] 作为输入。S盒是一个16x16的表，其中每一个元素是一个字节。对于输入的每一个字节，前四位组成十六进制数 x 作为行号，后四位组成的十六进制数 y 作为列号，查找表中对应的值。最后函数输出 4 个新字节组成的 32-bit 字。（S盒和逆S盒在程序中已经提前声明了一个结构体）
3. 轮常数`Rcon[]`，如何计算的就不说了，直接把它当做常量数组。
4. 扩展密钥数组w[]的前 Nk 个元素就是外部密钥 K，以后的元素w[i]等于它前一个元素w[i-1]与前第 Nk 个元素w[i-Nk]的异或，即w[i] = w[i-1] XOR w[i-Nk]；但若 i 为 Nk 的倍数，则`w[i] = w[i-Nk] XOR wordbyte_sub(loop_wordbyte(w[i-1])) XOR Rcon[i/Nk-1]`。


在本次的实验中主要采用的是字符型的变量来进行参数的传递和转移，但是在计算的过程中会将字符型的数组转变为数字，但由于128位的数字太大，所以将其分为4组，每一个都由四个8进制数来构成，如下所示：

```c++
vector<string> group_key(string& key)
{
    // 四组
    vector<string> groups(4);
    // 初始下标
    int index = 0;
    // 分组
    for (string& g : groups)
    {
        g = key.substr(index, 8);
        index += 8;
    }
    return groups;
}
```

在密钥扩展中，当下标为4的倍数的时候，进行的过程较为复杂，此部分的流程图如下所示：

![](https://i.imgtg.com/2022/12/28/EJ6tc.jpg)




***AES加密***


AES加密总共大体上可分为4个部分来构造，分别为S盒变换、行变换、列变换以及与扩展密钥的异或，各个部分的大致内容如下：

> S盒变换-wordbyte_sub()


在密钥扩展部分已经讲过了，S盒是一个 16 行 16 列的表，表中每个元素都是一个字节。S盒变换很简单：函数wordbyte_sub()接受一个 4x4 的字节矩阵作为输入，对其中的每个字节，前四位组成十六进制数 x 作为行号，后四位组成的十六进制数 y 作为列号，查找表中对应的值替换原来位置上的字节。


> 行变换-move_row()

行变换也很简单，它仅仅是将矩阵的每一行以字节为单位循环移位：第一行不变，第二行左移一位，第三行左移两位，第四行左移三位。


> 列变换-col_confuse()

函数col_confuse()同样接受一个 4x4 的字节矩阵作为输入，并对矩阵进行逐列变换，注意公式中用到的乘法是伽罗华域（GF，有限域）上的乘法。

> 与扩展密钥的异或-string_xor()

扩展密钥只参与了这一步。根据当前加密的轮数，用w[]中的 4 个扩展密钥与矩阵的 4 个列进行按位异或。到这里 AES 加密的各个部分差不多了了。

> 流程图

最后AES加密的流程图如下图所示：

![](https://i.imgtg.com/2022/12/28/EJ93v.jpg)


***AES解密***


AES解密与AES加密类似，基本上都是其加密的逆过程，总共大体上也可分为4个部分来构造，分别为逆行变换、逆 S 盒变换、逆列变换以及与扩展密钥的异或，各个部分的大致内容如下（由于与扩展密钥的异或和AES加密的部分一样，在这里就不再过多赘述）：

> 逆行变换-in_move_row()

上面讲到`move_row()`是对矩阵的每一行进行循环左移，所以`in_move_row()`是对矩阵每一行进行循环右移。


> 逆 S 盒变换-in_wordbyte_sub()

与 S 盒变换一样，也是查表，查表的方式也一样，只不过查的是另外一个置换表（S-Box的逆表）。


> 逆列变换-in_col_confuse()


与列变换的方式一样，只不过计算公式的系数矩阵发生了变化，只要写出三个逆变换的函数，然后根据伪代码就很容易实现 AES 解密算法了。



> 流程图


最后AES解密的流程图如下图所示：

![](https://i.imgtg.com/2022/12/28/EJ2iq.jpg)


###  5.2. <a name='-1'></a>代码实现


各类的结构体（即书本上出现的置换表以及各种扩展和置换运算）已经预先定义


> 各类预处理函数

- 首先是对字节循环的实现

```c++
string loop_wordbyte(string& wi_1)
{
    string ans = wi_1.substr(2) + wi_1.substr(0, 2);
    return ans;
}
```


- 接下来是对字节代换的实现

```c++
string wordbyte_sub(string& wi_1)
{
    int len = wi_1.length();
    string ans = "";
    for (int i = 0; i < len; i += 2)
    {
        // 先获取当前的下标
        int x = ch_to_int(wi_1[i]), y = ch_to_int(wi_1[i + 1]);
        // 然后获取当前的数字
        int num = S[x][y];
        // 先将数值转化为字符串
        string s = int_to_chs(num);
        // 然后不足的话补0
        while (s.length() < 2)
        {
            s = "0" + s;
        }

        // 加起来
        ans += s;
    }
    return ans;
}
```


- 然后是对密钥的轮常量异或的实现


```c++
string xor_with_const(string& wi_1, int rounds)
{
    // 先将字符串变为数字
    long long num = 0;
    for (int i = 0; i < 8; ++i)
    {
        char ch = wi_1[i];
        num = num * 16 + ch_to_int(ch);
    }
    // 计算异或结果
    num ^= Rcon[rounds];

    // 将num转化为字符串
    string res = int_to_chs(num);
    while (res.length() < 8)
    {
        res = "0" + res;
    }
    return res;
}
```



- 密钥拓展的时候，下标为4的倍数时，需要使用一个特殊的变换函数


```c++
string T(string& wi_1, int round)
{
    // T 变换由3部分构成，用的即为上述描述的三个函数
    // 先进行字循环
    string ans = loop_wordbyte(wi_1);
    // 然后字节代换
    ans = wordbyte_sub(ans);
    // 最后是轮异或
    ans = xor_with_const(ans, round);

    return ans;
}
```





- 密钥编排的实现


```c++
vector<string> extend_key(string& key)
{
    // 先分组
    vector<string> w_key = group_key(key);
    for (int i = 0; i < 40; ++i)
    {
        string w = "";
        int index = 4 + i;
        string temp = w_key[index - 1];
        // 4 的倍数的时候，需要调用T函数
        if (index % 4 == 0)
        {
            temp = T(temp, index / 4 - 1);
        }
        w = string_xor(temp, w_key[index - 4]);

        // 压入数组中
        w_key.push_back(w);
    }

    return w_key;
}
```






- 行移位函数的实现


```c++
vector<string> move_row(vector<string>& s)
{
    vector<string> ans = s;
    // 字符串数组每个对应一列, 所以是对应到列进行移位
    // 一行对应有两个16进制数，所以需要两个一起移动，相当于两列一起移动
    for (int i = 0; i < 4; ++i)
    {
        int k = i * 2;
        // 就原本矩阵对应的行移位，对于字符串数组就是列移位
        for (int j = 0; j < 4; ++j)
        {
            ans[j][k] = s[(j + i) % 4][k];
            ans[j][k + 1] = s[(j + i) % 4][k + 1];
        }
    }
    return ans;
}
```



- 列混淆函数的实现


```c++
vector<string> col_confuse(vector<string>& s)
{
    vector<string> ans = s;
    // 算法中对应的是列，这边就直接变成了行，即字符
    for (int i = 0; i < 4; ++i)
    {
        // 需要先将字符串拆分成两两一组，共4组
        auto temp = split_s(s[i]);
        // 先转成数字
        int s0 = str_long(temp[0]), s1 = str_long(temp[1]), s2 = str_long(temp[2]),
            s3 = str_long(temp[3]);
        // 计算混淆后的值
        int t0 = power(s0) ^ power(s1) ^ s1 ^ s2 ^ s3;
        int t1 = s0 ^ power(s1) ^ power(s2) ^ s2 ^ s3;
        int t2 = s0 ^ s1 ^ power(s2) ^ s3 ^ power(s3);
        int t3 = s0 ^ power(s0) ^ s1 ^ s2 ^ power(s3);
        // 转换成字符串再相加
        ans[i] = int_ch2(t0) + int_ch2(t1) + int_ch2(t2) + int_ch2(t3);
    }
    return ans;
}
```





- 行移位的逆操作函数的实现


```c++
vector<string> in_move_row(vector<string>& s)
{
    vector<string> ans = s;
    // 现在变成了逆操作
    for (int i = 0; i < 4; ++i)
    {
        int k = i * 2;
        // 就原本矩阵对应的行移位，对于字符串数组就是列移位
        for (int j = 0; j < 4; ++j)
        {
            ans[j][k] = s[(j - i + 4) % 4][k];
            ans[j][k + 1] = s[(j - i + 4) % 4][k + 1];
        }
    }
    return ans;
}
```



- 逆字节代换的实现


```c++
string in_wordbyte_sub(string& wi_1)
{
    int len = wi_1.length();
    string ans = "";
    for (int i = 0; i < len; i += 2)
    {
        // 先获取当前的下标
        int x = ch_to_int(wi_1[i]), y = ch_to_int(wi_1[i + 1]);
        // 然后获取当前的数字
        int num = S1[x][y];
        // 先将数值转化为字符串
        string s = int_to_chs(num);
        // 然后不足的话补0
        while (s.length() < 2)
        {
            s = "0" + s;
        }

        // 加起来
        ans += s;
    }
    return ans;
}

```




- 列混淆函数的逆变换实现


```c++
vector<string> in_col_confuse(vector<string>& s)
{
    // 逆变换其实原来的变换矩阵的逆矩阵，对应0xe, 0xb, 0xd, 0x9
    // 4 列

    vector<string> ans = s;
    for (int i = 0; i < 4; ++i)
    {
        // 先分割成4个两位数字
        auto temp = split_s(s[i]);
        // 转换成数字
        vector<int> nums(4);
        for (int j = 0; j < 4; ++j)
        {
            nums[j] = str_long(temp[j]);
        }
        vector<int> t4(4, 0);
        for (int j = 0; j < 4; ++j)
        {
            for (int t = 0; t < 4; ++t)
            {
                int k = (t - j + 4) % 4;
                t4[j] ^= power(power(power(nums[t])));        // 表示8
                switch (k)
                {
                case 0:        // 0xe = 8 + 4 + 2
                {
                    t4[j] ^= power(power(nums[t])) ^ power(nums[t]);
                    break;
                }
                case 1:        // 0xb = 8 + 2 + 1
                {
                    t4[j] ^= power(nums[t]) ^ nums[t];
                    break;
                }
                case 2:        // 0xd = 8 + 4 + 1
                {
                    t4[j] ^= power(power(nums[t])) ^ nums[t];
                    break;
                }
                default:    // 0x9 = 8 + 1
                    t4[j] ^= nums[t];
                    break;
                }

            }
        }
        // 将数字转换成字符串存储
        ans[i] = int_ch2(t4[0]) + int_ch2(t4[1]) + int_ch2(t4[2]) + int_ch2(t4[3]);
    }

    return ans;
}
```





> 加密过程

- 按流程图进行实现

```c++
vector<string> aes(string& plain_text, string& key)
{
    // 先拓展密钥
    vector<string> keys = extend_key(key);

    int index = 0;
    // 然后就是10轮迭代
    // 需要知道明文其实是32位，所以需要搞4下
    // 可以先把明文也分组

    // 一开始的先进行一次轮密钥加
    vector<string> texts = group_key(plain_text);
    for (int i = 0; i < 4; ++i)
    {
        texts[i] = string_xor(texts[i], keys[i]);
    }
    index += 4;
    
    // 然后十次迭代
    for (int k = 0; k < 10; ++k)
    {
        for (int j = 0; j < 4; ++j)
        {
            // 先是字节代换
            texts[j] = wordbyte_sub(texts[j]);
        }
        // 然后是行移位
        texts = move_row(texts);

        if (k < 9)
        {
            // 再来列混淆
            texts = col_confuse(texts);
        }

        // 轮密钥加
        for (int i = 0; i < 4; ++i)
        {
            texts[i] = string_xor(texts[i], keys[i + index]);
        }

        index += 4;
    }

    // 最后进行输出
//    show(texts);
    return texts;
}
```

> 解密过程


- 按流程图进行实现

```c++
vector<string> in_aes(string& text, string& key)
{
    // 先拓展密钥
    auto keys = extend_key(key);

    // 初始下标
    int index = 40;

    // 对密文分组
    vector<string> texts = group_key(text);
    
    // 一开始先进行依次轮密钥加
    for (int i = 0; i < 4; ++i)
    {
        texts[i] = string_xor(texts[i], keys[index + i]);
    }
    index -= 4;

    // 然后十次迭代
    for (int i = 0; i < 10; ++i)
    {
        // 先逆行移位
        texts = in_move_row(texts);

        // 然后是字节代换逆操作
        for (int j = 0; j < 4; ++j)
        {
            texts[j] = in_wordbyte_sub(texts[j]);
        }

        // 轮密钥加
        for (int j = 0; j < 4; ++j)
        {
            texts[j] = string_xor(texts[j], keys[index + j]);
        }

        // 除了最后一轮，都要列混淆逆变换
        if (i < 9)
        {
            texts = in_col_confuse(texts);
        }
        index -= 4;
    }

//    show(texts);
    
    return texts;
}
```


###  5.3. <a name='CBC'></a>`CBC`模式的补充


***(1)`CBC`概念***

CBC模式的全称是Cipher Block Chaining模式（密文分组链接模式），之所以叫这个名字，是因为密文分组像链条一样相互连接在一起。在CBC模式中，首先将明文分组与前一个密文分组进行XOR运算，然后再进行加密。


> 初始化向量

当加密第一个明文分组时，由于不存在“前一个密文分组”，因此需要事先准备一个长度为一个分组的比特序列来代替“前一个密文分组”，这个比特序列称为初始化向量（Initialization Vector），通常缩写为IV，一般来说，每次加密时都会随机产生一个不同的比特序列来作为初始化向量。

> CBC模式的特点


明文分组在加密之前一定会与“前一个密文分组”进行XOR运算，因此即使明文分组1和明文分组2的值是相等的，密文分组1和2的值也不一定是相等的。这样一来，ECB模式的缺陷在CBC模式中就不存在了。

**加密过程：**

- 在CBC模式中，无法单独对一个中间的明文分组进行加密。例如，如果要生成密文分组3，则至少需要凑齐明文分组1、2、3才行。

**解密过程：**

- 假设CBC模式加密的密文分组中有一个分组损坏了。在这种情况下，只要密文分组的长度没有发生变化，则解密时最多只有2个分组受到数据损坏的影响。
- 假设CBC模式的密文分组中有一些比特缺失了，那么此时即便只缺失1比特，也会导致密文分组的长度发生变化，此后的分组发生错位，这样一来，缺失比特的位置之后的密文分组也就全部无法解密。



> 对CBC模式的攻击

假设主动攻击者的目的是通过修改密文来操纵解密后的明文。如果攻击者能够对初始化向量中的任意比特进行反转（将1变成0，将0变成1），则明文分组中相应的比特也会被反转。这是因为在CBC模式的解密过程中，第一个明文分组会和初始化向量进行XOR运算。


但是想对密文分组也进行同样的攻击就非常困难了。例如，如果攻击者将密文分组1中的某个比特进行反转，则明文分组2中相应比特也会被反转，然而这一比特的变化却对解密后的明文分组1中的多个比特造成了影响，也就是说，只让明文分1中所期望的特定比特发生变化是很困难的。


> 填充提示攻击

填充提示攻击是一种利用分组密码中填充部分来进行攻击的方法。在分组密码中，当明文长度不为分组长度的整数倍时，需要在最后一个分组中填充一些数据使其凑满一个分组长度。在填充提示攻击中，攻击者会反复发送一段密文，每次发送时都对填充数据进行少许改变。由于接收者（服务器）在无法正确解密时会返回一个错误消息，攻击者通过这一错误消息就可以获得一部分与明文相关的信息。这一攻击并不仅限于CBC模式，而是适用所有需要进行分组填充的模式。


**2014年对SSL3.0 造成了重大影响POODLE攻击实际上就是一种填充示攻击**


> 对初始化向量（IV）进行攻击

初始化向量（IV）必须使用不可预测的随机数。然而在SSL/TLS的TLS1.0版本协议中，IV并没有使用不可预测的随机数，而是使用上一次CBC模式加密时的最后一个分组。为了防御攻击者对此进行攻击，TLS1.1以上的版本中改为了必须显示传送IV。


> CBC模式应用

确保互联网安全的通信协议之一SSL/TLS，就是使用CBC模式来确保通信机密性的，如使用CBC模式三重DES的3DES_EDE_CBC以及CBC模式256比特AES的AES_256_CBC等。


***(2)`CBC`实现***

> 加密

由于已经实现了AES的单个加密，所以只需要将其整合起来即可：

- AES的CBC加密模式，默认iv是全零（这个称为初始化向量），由于是分组加密，所以下一组的iv，就用前一组的加密的密文来充当，本次由于字符串用16进制表示，所以就是32个4位，iv初始化为32个零
- 加密每一次循环首先是明文与iv异或，然后是进行加密得到密文，同时密文是下次加密的iv，最后将本次的密文设置为下次加密的iv


代码如下：

```c++
// 定义一个实现CBC分组加密的AES数据
string en_cbc_aes(string& plain_text, string& key)
{
    string en_plain_text;
    int text_len = plain_text.size() / 32 + 1;
    // 先实现分组
    vector<string> groups(text_len);
    // 初始下标
    int index = 0;
    // 分组
    for (string& g : groups)
    {
        g = plain_text.substr(index, 32);
        index += 32;
    }
    // CBC模式进行计算
    // AES的CBC加密模式，默认iv是全零（这个称为初始化向量），由于是分组加密，所以下一组的iv，就用前一组的加密的密文来充当
    // 本次由于字符串用16进制表示，所以就是32个4位，iv初始化为32个零
    string iv = "00000000000000000000000000000000";
    // 中间变量组
    vector<string> groups_wxn(text_len);
    // 最终变量组
    vector<string> groups_zyl(text_len);
    vector<string> texts;
    for (int w = 0; w < text_len; w++)
    {
        // 明文与iv异或
        groups_wxn[w] = string_xor(iv, groups[w]);
        // 进行加密得到密文，同时密文是下次加密的iv
        texts = aes(groups_wxn[w], key);
        groups_zyl[w] = texts[0] + texts[1] + texts[2] + texts[3];
        // 本次的密文是下次加密的iv
        iv = groups_zyl[w];
    }
    // 最后整合
    for (string& z : groups_zyl)
    {
        en_plain_text += z;
    }
    return en_plain_text;
}
```



> 解密


由于已经实现了AES的单个解密，所以只需要将其整合起来即可：

- AES的CBC解密模式，默认iv是全零（这个称为初始化向量），由于是分组解密，所以下一组的iv，就用前一组的解密的密文来充当，本次由于字符串用16进制表示，所以就是32个4位，iv初始化为32个零
- 加密每一次循环首先是密文块解密，然后是iv异或得到明文，最后设置下次解密用到的iv


代码如下：

```c++
// 定义一个实现CBC分组解密的AES数据
string de_cbc_aes(string& en_text, string& key)
{
    string de_text;
    int text_len = en_text.size() / 32 + 1;
    // 先实现分组
    vector<string> groups(text_len);
    // 初始下标
    int index = 0;
    // 分组
    for (string& x : groups)
    {
        x = en_text.substr(index, 32);
        index += 32;
    }
    // CBC模式进行计算
    // AES的CBC解密模式，默认iv是全零（这个称为初始化向量），由于是分组解密，所以下一组的iv，用前一组密文来充当
    // 本次由于字符串用16进制表示，所以就是32个4位，iv初始化为32个零，与加密的时候相同
    string iv = "00000000000000000000000000000000";
    // 中间变量组
    vector<string> groups_wxn(text_len);
    // 最终变量组
    vector<string> groups_zyl(text_len);
    vector<string> texts;
    for (int w = 0; w < text_len; w++)
    {
        // 密文块解密
        texts = in_aes(groups[w], key);
        groups_wxn[w] = texts[0] + texts[1] + texts[2] + texts[3];
        // 与iv异或得到明文
        groups_zyl[w] = string_xor(iv, groups_wxn[w]);
        // 设置下次解密用到的iv
        iv = groups_wxn[w];
    }
    // 最后整合
    for (string& z : groups_zyl)
    {
        de_text += z;
    }
    return de_text;
}
```



##  6. <a name='MD5'></a>`MD5`相关
---

###  6.1. <a name='-1'></a>概念介绍

MD5消息摘要算法，属Hash算法一类。MD5算法对输入任意长度的消息进行运行，产生一个128位的消息摘要(32位的数字字母混合码)。

> MD5主要特点

不可逆，相同数据的MD5值肯定一样，不同数据的MD5值不一样


(一个MD5理论上的确是可能对应无数多个原文的，因为MD5是有限多个的而原文可以是无数多个。比如主流使用的MD5将任意长度的“字节串映射为一个128bit的大整数。也就是一共有2^128种可能，大概是3.4*10^38，这个数字是有限多个的，而但是世界上可以被用来加密的原文则会有无数的可能性)



> MD5的性质


1. 压缩性：任意长度的数据，算出的MD5值长度都是固定的(相当于超损压缩)
2. 容易计算：从原数据计算出MD5值很容易
3. 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别
4. 弱抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的
5. 强抗碰撞：想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的



> MD5用途

1. 防止被篡改：
   1. 比如发送一个电子文档，发送前，我先得到MD5的输出结果a。然后在对方收到电子文档后，对方也得到一个MD5的输出结果b。如果a与b一样就代表中途未被篡改
   2. 比如我提供文件下载，为了防止不法分子在安装程序中添加木马，我可以在网站上公布由安装文件得到的MD5输出结果
   3. SVN在检测文件是否在CheckOut后被修改过，也是用到了MD5.

2. 防止直接看到明文：
    现在很多网站在数据库存储用户的密码的时候都是存储用户密码的MD5值。这样就算不法分子得到数据库的用户密码的MD5值，也无法知道用户的密码。（比如在UNIX系统中用户的密码就是以MD5（或其它类似的算法）经加密后存储在文件系统中。当用户登录的时候，系统把用户输入的密码计算成MD5值，然后再去和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。这不但可以避免用户的密码被具有系统管理员权限的用户知道，而且还在一定程度上增加了密码被破解的难度。）

3. 防止抵赖（数字签名）：
    这需要一个第三方认证机构。例如A写了一个文件，认证机构对此文件用MD5算法产生摘要信息并做好记录。若以后A说这文件不是他写的，权威机构只需对此文件重新产生摘要信息，然后跟记录在册的摘要信息进行比对，相同的话，就证明是A写的了。这就是所谓的“数字签名”。



###  6.2. <a name='-1'></a>重要函数分析


***(1)`zip()`函数***

- 首先zip函数，如四个运算和循环左移等F(),G(),H(),I(),leftshift()，四轮函数计算等
- 然后把这些函数整合起来放入
- 在能够压缩处理之前，还需要对数据进行分组，采用for循环，将数据分为32位一组
- 然后再执行一些列计算操作

***(2)`encode()`函数***

- 加密函数将`int`数组转换为`char`，即将十进制转换为十六进制
- 在转换时，使用小端序存放结果

***(3)`init()`函数***

1. 首先设定了一个count[2]数组，负责记录当前字符串`位数`
2. 获取当前已有的字节数（count[0]>>3再模64）
3. 接下来用`count[0]+len<<3`，即已有位数加上新增加的位数
4. 然后判断是否有溢出
5. 若有，则将高位`count[1]+1`
6. 让count[1]获取高位的位数，即先让len右移32得到高位，再左移3位得到位数，即count[1]+=len>>29
7. 将新加入字符长度与待填充长度进行比较，在第一次调用此函数时，等同于将输入的字符串字节数与64字节数即512比特进行比较
8. 若大于等于，则可以先将数据按64字节分组，先对这些64字节的组执行压缩函数，然后再对最后一组不足64字节的数据执行后续填充操作等
9. 最后函数执行`memcpy(&buffer[nowlength], &input[i], len - i)`，进行拷贝。

***(4)`get_digest()`函数***

该函数负责对最后一组进行填充、压缩等操作：

1. 首先将count中计算的数据长度用encode转换，转换完的数据可以直接填在最后8字节
2. 接着获取当前数据已有的字节，计算填充字节长度，如果长度小于56字节即448比特，则填充字节=`56-数据字节`，否则，填充字节=`120-数据字`
3. 填充字节是以1开头，后续全是0，则构造一个数组tinachong[64]，其开头为0x80即10000000，用这个数组进行填充
4. 调用刚刚的`init(tianchong, padLen)`将填充数组的内容以一定长度填入我们的最后一个分组
5. 将最后8字节填入之前算好数据长度，再调用压缩函数进行计算即可


***(5)`getstring()`函数***

- 获得加密后的字符串函数使用for循环，将数据转化为16进制数


> 总体流程图如下所示：

![](https://i.imgtg.com/2022/12/28/EJubM.png)


**较为重要的函数到这里结束，接下来给出相应的代码**


###  6.3. <a name='-1'></a>代码实现


- 首先还是为了方便后面的雪崩效应写的将16进制字符串转换为2进制bit流的函数

```c++
void getbit(string a, bitset<128>& temp)
{
    int num = 127;
    // 如果无前缀0x 则这里i需要从2开始
    for (int i = 0; i < a.length(); i++)
    {
        if (a[i] <= '9')
        {
            for (int j = 0; j < 4; j++)
            {
                temp[num--] = HexToBit[a[i] - 48][j];
            }
        }
        else
        {
            for (int j = 0; j < 4; j++)
            {
                temp[num--] = HexToBit[a[i] - 65 + 10][j];
            }
        }
    }
}
```


- 接下来是4个轮函数的定义，其中F(),G(),H(),I()函数是书本上的基本逻辑函数

```c++
void round1(unsigned int& a, unsigned int& b, unsigned int& c, unsigned int& d, unsigned int& x, unsigned int s, unsigned int ac)
{
    a += F(b, c, d) + x + ac;
    a = leftshift(a, s);
    a += b;
}
void round2(unsigned int& a, unsigned int& b, unsigned int& c, unsigned int& d, unsigned int& x, unsigned int s, unsigned int ac)
{
    a += G(b, c, d) + x + ac;
    a = leftshift(a, s);
    a += b;
}
void round3(unsigned int& a, unsigned int& b, unsigned int& c, unsigned int& d, unsigned int& x, unsigned int s, unsigned int ac)
{
    a += H(b, c, d) + x + ac;
    a = leftshift(a, s);
    a += b;
}
void round4(unsigned int& a, unsigned int& b, unsigned int& c, unsigned int& d, unsigned int& x, unsigned int s, unsigned int ac)
{
    a += I(b, c, d) + x + ac;
    a = leftshift(a, s);
    a += b;
}
```



- 然后是填充和压缩函数

```c++
unsigned char* MD5::get_digest()
{
    if (!finished)
    {
        finished = true;
        
        unsigned char bits[8];
        unsigned int oldState[4];
        unsigned int oldCount[2];
        int nowlength, waitlength;
        
        memcpy(oldState, link, 16);
        memcpy(oldCount, count, 8);
        
        encode(count, bits, 8);
        
        nowlength = (unsigned int)((count[0] >> 3) & 0x3f);
        waitlength = (nowlength < 56) ? (56 - nowlength) : (120 - nowlength);
        init(tianchong, waitlength);
        
        
        nowlength = (unsigned int)((count[0] >> 3) & 0x3f);
        
        memcpy(&buffer[nowlength], bits, 8);
        zip(buffer);
        
        encode(link, digest, 16);
        memcpy(link, oldState, 16);
        memcpy(count, oldCount, 8);
    }
    return digest;
}
```




- 接下来是初始化函数

```c++
void MD5::init(unsigned char* input, int len)
{
    
    unsigned int i, nowlength, waitlength;
    
    finished = false;
    
    nowlength = (unsigned int)((count[0] >> 3) & 0x3f);
    count[0] += (unsigned int)len << 3;
    if ((count[0]) < ((unsigned int)len << 3)) {
        count[1] += 1;
    }
    count[1] += ((unsigned int)len >> 29);
    
    waitlength = 64 - nowlength;
    if (len >= waitlength) {
        memcpy(&buffer[nowlength], input, waitlength);
        zip(buffer);
        for (i = waitlength; i + 63 < len; i += 64) {
            zip(&input[i]);
        }
        nowlength = 0;
    }
    else {
        i = 0;
    }
    memcpy(&buffer[nowlength], &input[i], len - i);
}
```




- 接下来是压缩函数，整合全局步骤

```c++
void MD5::zip(unsigned char block[64])
{
    
    unsigned int a = link[0], b = link[1], c = link[2], d = link[3], x[16];
    for (int i = 0, j = 0; j < 64; ++i, j += 4)
    {
        x[i] = ((unsigned int)block[j]) | (((unsigned int)block[j + 1]) << 8) | (((unsigned int)block[j + 2]) << 16) | (((unsigned int)block[j + 3]) << 24);
    }
    round1(a, b, c, d, x[0], s[0][0], 0xd76aa478);
    round1(d, a, b, c, x[1], s[0][1], 0xe8c7b756);
    round1(c, d, a, b, x[2], s[0][2], 0x242070db);
    round1(b, c, d, a, x[3], s[0][3], 0xc1bdceee);
    round1(a, b, c, d, x[4], s[0][0], 0xf57c0faf);
    round1(d, a, b, c, x[5], s[0][1], 0x4787c62a);
    round1(c, d, a, b, x[6], s[0][2], 0xa8304613);
    round1(b, c, d, a, x[7], s[0][3], 0xfd469501);
    round1(a, b, c, d, x[8], s[0][0], 0x698098d8);
    round1(d, a, b, c, x[9], s[0][1], 0x8b44f7af);
    round1(c, d, a, b, x[10], s[0][2], 0xffff5bb1);
    round1(b, c, d, a, x[11], s[0][3], 0x895cd7be);
    round1(a, b, c, d, x[12], s[0][0], 0x6b901122);
    round1(d, a, b, c, x[13], s[0][1], 0xfd987193);
    round1(c, d, a, b, x[14], s[0][2], 0xa679438e);
    round1(b, c, d, a, x[15], s[0][3], 0x49b40821);
    
    round2(a, b, c, d, x[1], s[1][0], 0xf61e2562);
    round2(d, a, b, c, x[6], s[1][1], 0xc040b340);
    round2(c, d, a, b, x[11], s[1][2], 0x265e5a51);
    round2(b, c, d, a, x[0], s[1][3], 0xe9b6c7aa);
    round2(a, b, c, d, x[5], s[1][0], 0xd62f105d);
    round2(d, a, b, c, x[10], s[1][1], 0x2441453);
    round2(c, d, a, b, x[15], s[1][2], 0xd8a1e681);
    round2(b, c, d, a, x[4], s[1][3], 0xe7d3fbc8);
    round2(a, b, c, d, x[9], s[1][0], 0x21e1cde6);
    round2(d, a, b, c, x[14], s[1][1], 0xc33707d6);
    round2(c, d, a, b, x[3], s[1][2], 0xf4d50d87);
    round2(b, c, d, a, x[8], s[1][3], 0x455a14ed);
    round2(a, b, c, d, x[13], s[1][0], 0xa9e3e905);
    round2(d, a, b, c, x[2], s[1][1], 0xfcefa3f8);
    round2(c, d, a, b, x[7], s[1][2], 0x676f02d9);
    round2(b, c, d, a, x[12], s[1][3], 0x8d2a4c8a);
    
    round3(a, b, c, d, x[5], s[2][0], 0xfffa3942);
    round3(d, a, b, c, x[8], s[2][1], 0x8771f681);
    round3(c, d, a, b, x[11], s[2][2], 0x6d9d6122);
    round3(b, c, d, a, x[14], s[2][3], 0xfde5380c);
    round3(a, b, c, d, x[1], s[2][0], 0xa4beea44);
    round3(d, a, b, c, x[4], s[2][1], 0x4bdecfa9);
    round3(c, d, a, b, x[7], s[2][2], 0xf6bb4b60);
    round3(b, c, d, a, x[10], s[2][3], 0xbebfbc70);
    round3(a, b, c, d, x[13], s[2][0], 0x289b7ec6);
    round3(d, a, b, c, x[0], s[2][1], 0xeaa127fa);
    round3(c, d, a, b, x[3], s[2][2], 0xd4ef3085);
    round3(b, c, d, a, x[6], s[2][3], 0x4881d05);
    round3(a, b, c, d, x[9], s[2][0], 0xd9d4d039);
    round3(d, a, b, c, x[12], s[2][1], 0xe6db99e5);
    round3(c, d, a, b, x[15], s[2][2], 0x1fa27cf8);
    round3(b, c, d, a, x[2], s[2][3], 0xc4ac5665);
    
    round4(a, b, c, d, x[0], s[3][0], 0xf4292244);
    round4(d, a, b, c, x[7], s[3][1], 0x432aff97);
    round4(c, d, a, b, x[14], s[3][2], 0xab9423a7);
    round4(b, c, d, a, x[5], s[3][3], 0xfc93a039);
    round4(a, b, c, d, x[12], s[3][0], 0x655b59c3);
    round4(d, a, b, c, x[3], s[3][1], 0x8f0ccc92);
    round4(c, d, a, b, x[10], s[3][2], 0xffeff47d);
    round4(b, c, d, a, x[1], s[3][3], 0x85845dd1);
    round4(a, b, c, d, x[8], s[3][0], 0x6fa87e4f);
    round4(d, a, b, c, x[15], s[3][1], 0xfe2ce6e0);
    round4(c, d, a, b, x[6], s[3][2], 0xa3014314);
    round4(b, c, d, a, x[13], s[3][3], 0x4e0811a1);
    round4(a, b, c, d, x[4], s[3][0], 0xf7537e82);
    round4(d, a, b, c, x[11], s[3][1], 0xbd3af235);
    round4(c, d, a, b, x[2], s[3][2], 0x2ad7d2bb);
    round4(b, c, d, a, x[9], s[3][3], 0xeb86d391);
    
    link[0] += a;
    link[1] += b;
    link[2] += c;
    link[3] += d;
}
```




##  7. <a name='-1'></a>结果展示
---

到这里本次大作业也将近尾声了，最后展示一下通讯程序运行的结果：


###  7.1. <a name='AES-1'></a>开始的发送公钥和共享`AES`密钥

> 结果如图所示：

![](https://i.imgtg.com/2022/12/28/EJ3V1.jpg)


**可以看出与设计相同，实现正确**


###  7.2. <a name='-1'></a>收发消息

> 结果如图所示：

![](https://i.imgtg.com/2022/12/28/EJIgG.jpg)

**可以看出与设计相同，实现正确**


##  8. <a name='-1'></a>总结与展望
---


###  8.1. <a name='-1'></a>总结


本次是密码学的最后的大作业，在这次实验中其实是对整个学期的课程的总结，其中不仅用到了之前实验尝试过的`RSA`和`AES`算法来对密钥进行共享并对内容进行加密，还将消息认证码、数字签名等最后学习到的机制应用到本次的程序中，并且将网络课的通讯升级为`TCP`来结合到本次的程序中，整个实验让我对密码学方面（当然还有网络）的编程更加的熟悉。




###  8.2. <a name='-1'></a>展望


在大作业后，对密码学方面的知识更加的熟悉，也对这些加密算法和攻击方法更加的感兴趣，期待自己未来更好的发展，`万事胜意、心想事成、未来可期`。